<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[mac 10.14.76 Mojave系统安装nginx,php,mysql]]></title>
    <url>%2Fphp%2F84c1c2fb.html</url>
    <content type="text"><![CDATA[mac 10.14.76 Mojave系统自带的php为7.1.3如果只是简单调试php代码的环境已经足以.几分钟内即可搭建完整的lnmp环境 背景新入手一台mbp,所以需要装一个简单的lnmp跑一些简单的php脚本,Mojave系统自带php是7.1.3已经完全符合使用要求,只需要简单的改下配置即可,nginx和mysql更是直接使用brew 直接安装就行.但是brew install 不同版本的软件的时候已经更改为 php@71 而不是 php71这种,所以不确定的时候一定要先 brew search php|mysql 查看一下. nginx12345678910111213141516171819202122232425262728293031323334353637383940414243# 用mac 的包管理 brew 安装nginx$ brew install nginx# 启动nginx$ sudo nginx# 编辑nginx配置文件, 先改一下和项目路径 安装完nginx后配置文件默认就在 /usr/local/etc/nginx 下$ sudo vi /usr/local/etc/nginx/nginx.confhttp &#123; ... #gzip on; autoindex on; # 开启文件浏览 autoindex_exact_size off; # 显示kb大小 autoindex_localtime on; # 显示修改时间 ... server&#123; listen 80; server_name localhost; ... location / &#123; root /www; #php脚本位置 index index.html index.htm; &#125; ... location ~ \.php$ &#123; root /www; fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; # fastcgi_param SCRIPT_FILENAME /scripts$fastcgi_script_name; #自带的注释掉 改成下面的 fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; # 这个是解析php的 include fastcgi_params; &#125; &#125;wq!# 重新加载配置$ sudo nginx -s reload# nginx的几个命令 重新加载配置|重启|停止|退出$ sudo nginx -s reload|reopen|stop|quit php12345678910# 直接用系统自带的php,配置文件在 /private/etc下 先更改下log的位置$ sudo vi /private/etc/php-fpm.conferror_log = /usr/local/var/log/php-fpm.log #换成这个地址,不然启动会报一个日志的错# 复制一个 php-fpm的配置文件 不然启动报错找不到conf$ cd /private/etc/php-fpm.d/$ sudo cp www.conf.default www.conf#启动php-fpm$ sudo php-fpm mysql1234567891011121314151617181920212223242526272829303132333435363738394041424344# brew安装mysql, 成功后注意一下末尾有很重要的信息,我就是没看仔细 耽误了一会功夫$ brew install mysql@5.7...We've installed your MySQL database without a root password. To secure it run: mysql_secure_installation #初始化mysql的root 密码MySQL is configured to only allow connections from localhost by defaultTo connect run: mysql -urootmysql@5.7 is keg-only, which means it was not symlinked into /usr/local,because this is an alternate version of another formula.If you need to have mysql@5.7 first in your PATH run: echo 'export PATH="/usr/local/opt/mysql@5.7/bin:$PATH"' &gt;&gt; ~/.zshrc # 我用的zsh 所以需要把环境变量更新到配置文件For compilers to find mysql@5.7 you may need to set: export LDFLAGS="-L/usr/local/opt/mysql@5.7/lib" export CPPFLAGS="-I/usr/local/opt/mysql@5.7/include"For pkg-config to find mysql@5.7 you may need to set: export PKG_CONFIG_PATH="/usr/local/opt/mysql@5.7/lib/pkgconfig"To have launchd start mysql@5.7 now and restart at login: brew services start mysql@5.7 #brew services 管理 启动Or, if you don't want/need a background service you can just run: /usr/local/opt/mysql@5.7/bin/mysql.server start # 这个是用mysql直接启动#zsh下需要先增加环境变量$ echo 'export PATH="/usr/local/opt/mysql@5.7/bin:$PATH"' &gt;&gt; ~/.zshrc$ source ~/.zshrc#启动mysql$ /usr/local/opt/mysql@5.7/bin/mysql.server start#初始化密码$ mysql_secure_installation按照提示设置即可#登录mysql 输入上一步设置的 密码$ mysql -uroot -p 各个步骤容易出现的问题 苹果系统自带php-fpm启动报错No pool defined failed to post process the configuration FPM initialization failed 123456789101112131415#具体错误$ /etc sudo php-fpm No log handling enabled - using stderr loggingCreated directory: /var/db/net-snmpCreated directory: /var/db/net-snmp/mib_indexes[16-Aug-2019 20:36:21] WARNING: Nothing matches the include pattern '/private/etc/php-fpm.d/*.conf' from /private/etc/php-fpm.conf at line 125.[16-Aug-2019 20:36:21] ERROR: No pool defined. at least one pool section must be specified in config file[16-Aug-2019 20:36:21] ERROR: failed to post process the configuration[16-Aug-2019 20:36:21] ERROR: FPM initialization failed#解决方案:$ cd /private/etc/php-fpm.d/$ sudo cp www.conf.default www.conf# 重新启动php-fpm即可$ sudo php-fpm mysql 启动报错 ERROR 2002 (HY000): Can&#39;t connect to local MySQL server through socket &#39;/tmp/mysql.sock&#39; (2) 这是由于brew install mysql@5.7后没有启动mysql服务导致的,所以解决方案是直接启动mysql服务就好: 1$ /usr/local/opt/mysql@5.7/bin/mysql.server start]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>nginx</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Career_stage_yixia]]></title>
    <url>%2Fdefault%2F3d93082c.html</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[排序算法-快速排序]]></title>
    <url>%2Falgorithm%2Fsort%2F2f44d825.html</url>
    <content type="text"><![CDATA[图灵奖得主C. A. R. Hoare(托尼·霍尔)于1960时提出来的排序算法,使用非常广泛,速度也很快 原理总结为:给每一步的基准值找到它正确索引位置的过程.首先,选一个基准值(可以选第一个,可以选最后一个,可以选中间,本文选第一个),根据和基准值比大小分割成左边分区(比基准值小)和右边分区(比基准值大),利用分而治之递归处理左右两个分区(将每个分区再重复选基准值和分区),最终达到每个分区只有一个元素的时候即为基准条件(返回分区合并后的列表),归纳条件为分区的头和尾的游标不相等.这里需要仔细理解下分区递归处理. 实现过程先实现原地快速排序的方法, 给定一个无序列表 [3, 4, 1, 2, 5], 还需要为了左右开始遍历列表行程分区的2个游标 i(左侧) 和 j(右侧): 选定初始值为数组第一个元素 (选拔该次排序列表的基准值条件) 基准值: 3 列表:[3, 4, 1, 2, 5] 从列表末端向左侧开始进行对比,如果比基准值大就继续找(目的是把无序列表按照基准值为分界线分成左右2个分区),比基准值小的说明该位置的元素应该分配到基准值的左侧,而此时基准值已经被取走了,相当于左侧第一个元素的位置是空的,于是把该值赋予到左侧第一个 基准值: 3 小于基准值的元素: 2 列表:[2, 4, 1, 2(右侧游标j), 5] 因为找到了比基准值小的元素并且进行了重新赋值,所以现在2 的位置上相当于是空的(因为已经把2赋予给了列表第一个), 所以需要从左侧开始找比基准值大的元素.找到了 4 后进行和上一轮的游标j的值进行赋值操作 基准值: 3 大于基准值的元素: 4 列表: [2, 4(i位置), 1, 4(j上一轮位置,进行赋值为4), 5] 左侧已经找到了比基准值大的,所以又轮到右侧继续从 4 的索引位置开始向左寻找,并且找到了 1 比基准值小.进行和上一轮的i索引的值进行赋值操作 基准值: 3 小于基准值的元素: 1 列表: [2, 1(i上一轮位置), 1(此时j位置), 4, 5] i像右侧开始比大小时 i 和 j 已经相等了,说明已经遍历完所有元素,这个时候把基准值赋值到 i 和 j 的共同位置即可完成此次的排序 基准值: 3 列表: [2, 1, 3, 4, 5]这一轮已经进行完 分区的操作 以基准值 3 分为了 [2,1] 和 [4, 5]接下来的操作就是把这2个继续 按照 步骤操作,直到每个分区只有一个元素的时候就完成了所有列表的排序 代码12345678910111213141516def quickSort(list:'list', start, end)-&gt;list: k = start #记录初始位置的游标 j = end #记录结束位置的游标 if start &lt; end: # 基准条件 最外层的list分区里有2个索引, 因为至少2个元素才能进行排序 init = list[k] #初始化一个start位置的元素当基准值,最后需要填充到 j = k 索引的位置上 while j != k: #左右两侧不相等就说明2个游标未遍历完所有元素 while j &gt; k and list[j] &gt;= init: #遍历右侧的条件 j -= 1 list[k] = list[j] #进行赋值操作 while k &lt; j and list[k] &lt;= init: #遍历左侧的条件 k += 1 list[j] = list[k] #进行赋值操作 list[j] = init #该分区已经全部赋值完,把基准位置的值填入 j = k 的索引 quickSort(list, start, k-1) #把该列表里的左右分区递归的进行处理 quickSort(list, k+1, end) #把该列表里的左右分区递归的进行处理 return list #分区已经只有一个元素了 12345678#空间复杂度高,但是理解非常简单def quickSort(list:'list')-&gt;list: if len(list)&lt;2: #基准条件 return list init = list[0] #选基准值 left = [val for val in list[1:] if val &lt;= init] #比大小选出来左侧分区 right = [val for val in list[1:] if val &gt; init] #比大小选出来左侧分区 return quickSort(left) + [init] + quickSort(right) #递归处理 left 和 right分区]]></content>
      <categories>
        <category>algorithm</category>
        <category>sort</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法-直接选择排序]]></title>
    <url>%2Falgorithm%2Fsort%2F18e3fa36.html</url>
    <content type="text"><![CDATA[通过直接选择排序可以初步明白时间复杂度和空间复杂度的概念,以及直接选择排序的思路 实现过程现将一步一步的展现一个无序集合[2,1,5,3,7]进行直接选择排序(本文升序)的过程.首先将该集合分为2个部分,第一个部分为有序集合,第二个部分为无序集合,那么此时有序集合是空的[],而无序集合为[2,1,5,3,7],通过依次遍历原集合([2,1,5,3,7])的每一个元素记为A,循环的每个元素都去和无序集合里的每个值(遍历无序集合)进行对比,找到当次无序集合里的最小值(需要遍历此时的无序集合)B,然后交换A和B的位置,这样B就能进入到有序集合,A被交换到了无序集合里.具体过程如下: 开始遍历原集合(此时有序集合为[],无序集合为[2,1,5,3,7]),将集合中的第1个元素取出[2],然后开始和剩下的无序集合([1,5,3,7])进行对比,不和全部无序集合对比是因为自身和自身对比没意义,所以我们从无序集合的第2个开始进行比大小,我们找到了[1,5,3,7]里的[1],然后进行交换(2和1进行交换),此时原集合变为[1,2,5,3,7] 此时遍历出集合第2个元素(此时有序集合为[1],无序集合为[2,5,3,7]),将无序集合中的第1个元素取出[2] (因为被交换所以第2次又是2,例子没选好,懒得改了),然后开始和剩下的无序集合([5,3,7])进行对比,我们从此时的无序集合[2,5,3,7]的第2个开始进行比大小,我们发现[2,5,3,7]里没有比2还小的元素了,所以不用进行交换,因为此时的2就是这一轮最小的元素,此时原集合变为[1,2,5,3,7] 此时遍历出集合第3个元素(此时有序集合为[1,2],无序集合为[5,3,7]),将无序集合中的第一个元素取出[5] ,然后开始和剩下的无序集合([3,7])进行对比,我们从此时的无序集合[5,3,7]的第二个开始进行比大小,我们找到了[3,7]里比5还小的元素[3],所以两个进行交换,此时原集合变为[1,2,3,5,7] 此时遍历出集合第4个元素(此时有序集合为[1,2,3],无序集合为[5,7]),将无序集合中的第一个元素取出[5] ,然后开始和剩下的无序集合([7])进行对比,我们从此时的无序集合[5,7]的第二个开始进行比大小,我们发现[7]里没有比5还小的元素了,所以不用进行交换,因为此时的5就是这一轮最小的元素,此时原集合变为[1,2,3,5,7] 此时遍历出集合第5个元素(此时有序集合为[1,2,3,5],无序集合为[7]),将无序集合中的第一个元素取出[7] ,然后开始和剩下的无序集合([])进行对比,我们从此时的无序集合已经是空集合了,所以不用进行交换,因为此时的7就是这一轮最小的元素,此时原集合变为[1,2,3,5,7] 此时集合已经排序完毕,排序结果就是最后的有序集合[1,2,3,5,7],无序集合里已经没有元素了. 原理通过例子可以看出,集合有多少个元素就得遍历多少遍,所以需要第1个关键值,记录遍历集合的游标(记为i),在遍历元素的同时需要去找当前无序集合里的最小值,所以还需要2个关键游标,当前最小元素的游标(k),无序集合里的游标(j). 通过遍历集合我们先获取到当前 默认最小元素的游标 k 的值, 然后在无序集合遍历寻找比 k 的值 还小的值,把无序集合的当前的j赋值给k一直更新到无序集合遍历完毕, 这个时候如果 k 不等于初始值了,说明无序集合里有最小值的出现,交换k(已经更新为无序集合里最小值的游标)和i(第1层遍历的游标)的值,然后游标i进入下一轮的循环. 代码123456789def selectSort(list: 'list') -&gt; list: for i in range(len(list)): #循环目标列表,此时的i为遍历集合的游标 k = i #把当前游标选为默认的最小元素的游标 for j in range(i+1, len(list)): #用k的值,去和当前无序集合里的每一个值进行对比,所以要循环此时的无序集合,因为无序集合里的第一个和游标i的值相等,所以没有进行比大小的意义,所以循环是从无序集合里的i+1开始 if list[j] &lt; list[k]: #进行k的值和无序集合里j的值比大小 k = j #如果发现无序集合里有更小的,那就更新k的值(k是每轮当中最小值的游标,初始值是和无序集合里第1个相等) if k != i: #如果k的最终值已经和k的初始值i不一致了,说明无序集合里有最小值 list[k],list[i] = list[i], list[k] #那么就要交换2个游标的值 return list #返回排好序的list 总结空间复杂度为O(1),因为是在原数组内进行不断的交换,没有额外的空间占用.时间复杂度为O(n²),因为有嵌套循环,抛去常数后为n²的复杂度.直接选择排序只需要好好理解游标的概念即可.]]></content>
      <categories>
        <category>algorithm</category>
        <category>sort</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redis常用数据结构命令]]></title>
    <url>%2Fredis%2Fcommands%2Fae747e39.html</url>
    <content type="text"><![CDATA[redis作为一款高性能key-value数据库,还拥有持久化,多种数据类型,数据备份(主从)等优势,我们本篇先说结构和常用命令和使用场景 基础部分1.string类型string主要用于记录字符串类型的缓存数据,常用于存储对象,计数器,设计锁,字符串等常用命令:1234get set mget mset getset setex psetex setnx msetnxincr decr incby decrby incrbyfloat getrange setrange setbit getbit append 使用场景:get set mget mset常见于普通kv存储的业务命,getset是简化了get后再set的操作,setex psetex是把 set 和 expire / pexpire 简化成一个命令了,set现在已经支持多参数设置了,(最下面的总结会说明一些场 景下为什么使用简化的命令会提升性能,但是实际生产环境下需要结合业务和开发规范来决定)setnx msetnx 是redis实现锁的一个重要命令(set命令已经支持多参数设置可以实现设置锁且设置超时,避免死锁的风险),业务场景里可以通过该命令实现简单的互斥锁,也可以构建复杂的分布式锁.这里不展开incr decr incby decrby incrbyfloat 常见于计数器业务,或者信号量getrange setrange append常见业务逻辑很少用,特殊下的业务场景应该会比较方便,理解其命令用法即可setbit getbit 这2个命令也是特殊场景下的,实际生产之中我只在构建用户历史记录当中用过,不展开 2.list类型list常用于构建简单的任务队列常用命令:123rpush lpush rpop lpop brpop blpoprpoplpush brpoplpushllen lindex lrange ltrim lset 使用场景:rpush lpush rpop lpop brpop blpop队列的 入队 出队 基本操作, brpop属于阻塞pop,队列没有值的时候会等待到超时或出现值rpoplpush brpoplpush 构建双队列,保活队列常用命令,因为list并没有完整的消息队列功能,所以需要自己设计ack机制,这个时候就需要用到rpoplpush 保证 item 被消费的时候即使出现崩溃,或者异常能把item重新导入到任务队列里继续处理,把数据丢失做到最低llen lindex lrange ltrim lset 辅助队列的一些命令,比如业务逻辑涉及到定期裁剪,那就会用到 llen 和 ltrim,如果裁剪还有规则就会用到lrange 3.set类型set常用于需要使用集合的业务场景,比如存放需要存储观看记录,存储ip,存储手机号,存储手机号等等常用命令:123sadd spop sismember srandmemberscard smove srem smemberssdiff sdiffstore sinter sinterstore sunion sunionstore 使用场景:sadd spop sismember srandmember属于基本set操作,此pop是随机移除,srandmember是随机返回一个成员不移除scard smove srem smembers根据业务来控制set大小,或者其他有删除逻辑会用到这些命令sdiff sdiffstore sinter sinterstore sunion sunionstoreredis内部实现了差集,交集,并集的操作,但是实际生产环境里不建议使用这些命令,因为redis属于单线程应用,如果一个交集命令非常耗时会阻塞其他客户端的命令 4.zset类型zset使用场景非常丰富且高效,比如处理排行榜,用作处理队列业务,适用排序功能的业务场景,仅用2个zset结构可以构成一个支持多人订阅消息,还能保证不丢数据的功能,可以用于聊天室业务场景.常用命令:12345zadd zcard zincrby zcount zscore zrankzrevrank zrange zrevrange zrangebyscore zrevrangebyscore zrem zremrangebyrank zremrangebyscore zinterstore zunionstorezlexcount zrangebylex zremrangebylex 使用场景:zadd zcard zincrby zcount zscore zrank zset常用命令,其中zincrby是个成员incr操作的,适合用作排行榜的自增操作zrevrank zrange zrevrange zrangebyscore zrevrangebyscore 通过索引,分数正序倒序截取zset数据用zrem zremrangebyrank zremrangebyscore裁剪zset的常用命令zinterstore zunionstore集合运算zlexcount zrangebylex zremrangebylex这是一个骚功能,用于 自动识别场景, 比如通讯录里输入张开头 程序返回张开头的所有联系人, 就是用这几个命令实现的,具体做法是 ascall 表 z 的下一位是 {那么就可以 定位 张{ 就可以把张开头的人全部截取到 5.hash类型hash结构多用于存储对象,存储用户登录token,购物车等业务场景均适用常用命令:12hset hget hmset hmget hdel hlen hexists hincrby hincrbyfloat hsetnxhkeys hvals hgetall 使用场景:hset hget hmset hmget hdel hlen hexists hincrby hincrbyfloat hsetnx常用操作命令hkeys hvals hgetall 在hash特别大的时候 hgetall 会造成阻塞, 所以可以用 hkeys 和 hvals 结合使用 其他常用命令1type rename del sort expire 常用的改名,删除键,设置过期时间(单位:秒) 最后实际生产当中最常用的数据类型就是string,包括string可以代替set,zset,hash结构.因为string的速度是最快的,对redis的cpu没有什么消耗,越复杂的结构对redis性能越有影响,而redis是一个单线程应用,如果某个客户端进行复杂结构的运算, 比如 set 和 zset 进行大数量的集合运算,排序等等,就会造成其他客户端阻塞,从而引发更多的问题出现,所以当结构能优化成string时,最好用string,可以把逻辑运算的成本放在业务机器上. 其他结构也需要结合业务来慎重使用,避免热key或者慢查询的情况出现,高并发场景下需要结合业务做多层缓存,碎片化缓存看情况而合并成大缓存,提高响应性能,其他想到什么再写进来.]]></content>
      <categories>
        <category>redis</category>
        <category>commands</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线性代数复习]]></title>
    <url>%2Fmath%2F74d71323.html</url>
    <content type="text"><![CDATA[最近在看机器学习部分发现线性代数里的很多名词和性质都完全忘记了,找了一个国外的教材复习了下 复习过程最近看了2本书, 一本是乔希·维茨金的 [学习之道],一本番茄工作法,都是说如何高效成为一个领域的优秀者,但是问题是生活之中不可确定的因素太多了,非常容易打断计划和安排,所以结合这2本书的内容发现自己还应该遵循一条,当务之急就赶紧做,不要去纠结是不是在规定时间内完成后要休息什么的,不光要赶紧做,还要连续做,举个例子,今晚要看线性代数,那么在晚饭后休息后就立马开始看,即使超过了番茄时间也要看,因为不知道下一刻会发生什么就打断了学习的计划,所以别死板守着这些高效的方法来安排学习,别让制定计划的时间超过学习的时间,断断续续3周才把线性代数比较笼统的复习了一下.也是因为不断的实践自己实际学习的效率. 线性代数结合几何的思维导图]]></content>
      <categories>
        <category>math</category>
      </categories>
      <tags>
        <tag>线性代数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[断更5个月的原因]]></title>
    <url>%2Fdiary%2F3fb389a1.html</url>
    <content type="text"><![CDATA[此次博客断更5个月,其中有自己的懒惰,也有外部很多因素,各占一半,不过还好,想更新的内容都被记录在各种文档里了 工作从时间线重新捋一下这5个月发生的事 [11月/18年] 开始对推荐系统感兴趣 产生这个想法是因为自己之前的几个项目中推荐系统的实现只是少量的借助了一些推荐算法,推荐系统的的优化又对产品的体验和各项数据影响十分巨大,所以我想很好的了解下目前主流的推荐系统都是如何完成推荐工作. [12月/18年] 买了两本推荐系统的书工作变动,调入新的项目组 网上的博客或者资料大部分都是作者记录的一些关键点,对于初学者还是找几本书全面系统的了解下会更有帮助,在各大论坛里确定了2本我觉得当时对我能迅速了解推荐系统的书工作上发生重要变动,进入新的项目组,并且占用了空余时间来支撑项目. [1月/19年] 为支撑项目加班,一月累计加班时长85小时,累所幸项目之初就申请负责推荐系统的实现,事实证明哪怕完成一个简单的推荐系统也不是一个容易的事 18年1月做直播答题,加班的很疯狂.半夜2点多是常态,19年又是这个样子,感觉1月份特别不友好新项目里负责的推荐和推荐算法没有太大关系,因为没有大数据的支撑,且由于人员紧张,只有我一个人来实现整个推荐系统,包括了推荐库,推荐逻辑,上报日志的处理,用户滤重.虽然没有用到什么推荐算法,但是也差不多实现了基于标签的喜好来推荐.发现还是在实际项目中会学习的更快一点,因为遇到的问题都会直接影响用户体验,所以要考虑的更周全一点.所幸全部联调上线后并没有出过大的线上bug. [2月/19年] 新项目占用了绝大部分时间,剩余时间只想休息 过完年后回来就是不停的优化推荐方案,优化推荐接口的响应时长,在这其中又加深了jmeter的操作能力,xhprof的性能调优,redis的性能瓶颈分析,布隆过滤器,最终结果就是平均800ms的延时最终控制在了300ms左右. [3月/19年] 项目开始进入稳定迭代,有时间整理和继续学习推荐相关 项目进入稳定迭代了,终于有空余的时间了,但是部门也调整了上班作息,相当于每天被压缩了3个小时的空余时间,心累.周末时不时也得处理点问题,不过还好,项目终于接入大数据团队了. [4月/19年] 发现想买新书,因为已买的实体书太多了,买了一个kindle. 想买几本书,发现家里实体书已经很多了,就买了一个kindle,希望能一直用它看书,看完的第一本是番茄工作法图解,想科学的改善下仅有的空余时间的利用率 记得当时只是简单的在谷歌百度搜索推荐系统相关的博客,搜索推荐算法的实例,发现和机器学习有关联,于是又了解了下机器学习相关的,发现优质的学习资料大多是英文,可是自己英文又不好,又想看看如何提升英语水平,但是看了一阵觉得这不是当务之急,于是尽量看翻译版的论文和资料,又发现里面用到了很多高数,线性代数,概率论的知识,于是立即下单买了这几本书教材,一复习傻逼了,符号都认不全了,下定决心要好好搞一搞高数了,找了一本国外的教材,发现实体书实在太多,买了一个kindle,但是发现kindle看这种教材很不方便,看公式看代码分页特别不舒服,但是先这样吧.学习不就是这么一步一步被耽误了么,还是吃鸡来的更刺激一点,没事还是多吃吃鸡,多出去逛逛街 生活 滑雪 18/19雪季终于从只会后刃推坡的初学者到能双脚换刃上中级道了,还教会了两个表弟,一个同事推坡.19年的目标是自由换刃外加刷几个地方的雪场,别的都好就是雪票太烧钱,不过滑雪本身还是很爽的一件事,能忘记很多事情. 厨艺 最近新学了一个黄焖鸡,味道还不错去了一个粤菜馆,吃了道爆炒水潺,入口即化的肉,口感非常不错 摄影 开始看相关技巧,打算夏天出图,单反都放好几年没用过了.罪过罪过. 股票 投资和投机在有些时候是没差别的,但是股票能放大自身的很多弱点,比如贪婪和恐惧,贪婪更多的收益却恐惧更大的风险,这方面还需要继续磨练和学习. END对于18年开始的互联网寒冬什么的,有过焦虑,也有过迷茫,但是想想别的行业不都有这种经历么,保持学习的心态就好了.]]></content>
      <categories>
        <category>diary</category>
      </categories>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何一条Mediainfo --Inform语句同时获取视频参数和音频参数多个Parameters]]></title>
    <url>%2Fserver%2Fcdb35a50.html</url>
    <content type="text"><![CDATA[mediainfo是一个能获取多媒体文件详细信息的软件,包括内容信息,视频信息,音频信息,文本信息等,有了它我们可以查看视频的宽高,比例,播放时长,音轨,比特率等等信息 准备工作参考php-mediainfo教程安装mediainfo并实际操作栗子看能否正确调用mediainfo命令 命令详解先让我们看下一个普通视频文件的信息都包含哪些1234567891011121314151617181920212223242526272829303132333435363738394041$ mediainfo 'http://samples.mplayerhq.hu/FLV/Enigma_Principles_of_Lust-part.flv'GeneralComplete name : http://samples.mplayerhq.hu/FLV/Enigma_Principles_of_Lust-part.flvFormat : Flash VideoFile size : 500 KiBDuration : 11 s 711 msOverall bit rate : 350 kb/sTagged date : UTC 2011-02-27 11:00:33Tagging application : inlet media FLVTool2 v1.0.6 - http://www.inlet-media.de/flvtool2VideoFormat : AVCFormat/Info : Advanced Video CodecFormat profile : Main@L2.1Format settings : CABAC / 3 Ref FramesFormat settings, CABAC : YesFormat settings, ReFrames : 3 framesCodec ID : 7Duration : 11 s 711 msWidth : 426 pixelsHeight : 240 pixelsDisplay aspect ratio : 16:9Frame rate mode : ConstantFrame rate : 30.000 FPSOriginal frame rate : 29.970 (29970/1000) FPSColor space : YUVChroma subsampling : 4:2:0Bit depth : 8 bitsScan type : ProgressiveAudioFormat : AACFormat/Info : Advanced Audio CodecFormat profile : LCCodec ID : 10-2Duration : 11 s 702 msChannel(s) : 2 channelsChannel positions : Front: L RSampling rate : 22.05 kHzFrame rate : 21.533 FPS (1024 SPF)Compression mode : Lossy 能看到格式,size大小,宽,高,duration等等常用信息,让我们一一用mediainfo命令来获取 获取文件格式12$ mediainfo --Inform="General;%Format%" 'http://samples.mplayerhq.hu/FLV/Enigma_Principles_of_Lust-part.flv'Flash Video 返回的是general下的format信息,比如你要的是video下的format信息呢12$ mediainfo --Inform="Video;%Format%" 'http://samples.mplayerhq.hu/FLV/Enigma_Principles_of_Lust-part.flv'AVC 这会拿到的是Video信息下的format,切记这里获取参数的大小写是严格区分的.这2个栗子可以发现如果想获取mediainfo各个参数的信息是先找到 分类名(类似General,Video,Audio)-&gt;参数(Format,Width这种),格式就是 用mediainfo的Inform mediainfo --Inform=&quot;分类名;%参数名%&quot; &#39;http://samples.mplayerhq.hu/FLV/Enigma_Principles_of_Lust-part.flv&#39; 这个格式记住可以获取你想要的任何参数 让我们来练习一下:套用格式获取duration信息12$ mediainfo --Inform="Video;%Duration%" 'http://samples.mplayerhq.hu/FLV/Enigma_Principles_of_Lust-part.flv'11711 我们可以看到取出来的播放时长单位是毫秒,而不是秒. 再来尝试一下获取文件大小:1$ mediainfo --Inform="General;%File size%" 'http://samples.mplayerhq.hu/FLV/Enigma_Principles_of_Lust-part.flv' ??? 为什么返回值是空呢,格式没有错却无法获得文件的大小.因为在显示的参数都是格式化后的,所以你会看到File size之间是有空格的,如果想获得文件大小应该替换成FileSize12$ mediainfo --Inform="General;%FileSize%" 'http://samples.mplayerhq.hu/FLV/Enigma_Principles_of_Lust-part.flv'512000 此时就顺利获取到了文件大小,那如何知道各个参数的真正参数名呢,用这个命令可以获取所有的详细参数的真实参数名12345678$ mediainfo --Info-ParametersGeneralCount : Count of objects available in this streamStatus : bit field (0=IsAccepted, 1=IsFilled, 2=IsUpdated, 3=IsFinished)StreamCount : Count of streams of that kind availableStreamKind : Stream type nameStreamKind/String : Stream type name....此处省略剩余行信息 参数显示的太多,不方便我们查找,我们可以输出到一个txt文件里1$ mediainfo --Info-Parameters &gt; mediainfo_parameters.txt 打开mediainfo_parameters.txt可以搜索FileSize那行显示 FileSize : File size in bytes,同理我们根据这个可以获得你所需要的参数信息 看到这里你可能已经能熟练使用这个命令获取单个参数值,但是实际场景中可能获取的参数是多个的例如:同时获取视频的宽,高,播放时长?很简单每个参数都用%%包裹起来然后每个参数用,分割即可,命令如下:12$ mediainfo --Inform="Video;%Width%,%Height%,%Duration%" 'http://samples.mplayerhq.hu/FLV/Enigma_Principles_of_Lust-part.flv'426,240,11711 此时我们可以一条语句获得视频的宽,高,播放时长信息,这里的 逗号 可以替换别的字符,你可以用空格,|等可以自行尝试一下,反正解析数据的时候对应好相应的字符就行.简单例子:12$ mediainfo --Inform="Video;%Width%|%Height%|%Duration%" 'http://samples.mplayerhq.hu/FLV/Enigma_Principles_of_Lust-part.flv'426|240|11711 看到这里,你已经会用一条命令获取一个分类下的多个参数信息了,那么如果是要求同时获取视频的宽,高,播放时长,音频的format多个参数信息可以么?这个问题当初也困扰了我一阵,命令各种尝试之下终无解,最后发现mediainfo的inform命令是支持文件执行的.例子如下:12345678910111213141516#编辑一个文本放 一行命令vi 1.txtVideo;%Width%|%Height%|%Duration%wq#命令调用该文本$ mediainfo --Inform="file://1.txt" 'http://samples.mplayerhq.hu/FLV/Enigma_Principles_of_Lust-part.flv'426|240|11711#修改文本命令如下vi 1.txtVideo;%Width%,%Height%,%Duration%,Audio;%Format%wq#重新执行命令$ mediainfo --Inform="file://1.txt" 'http://samples.mplayerhq.hu/FLV/Enigma_Principles_of_Lust-part.flv'426,240,11711,AAC 此时可以看到一条命令已经可以获得视频的宽高播放时长和音频的format信息 最后有的人会想为什么一定要一条命令这么费劲巴拉的处理问题呢?多一条命令也不会多慢?当你处理几条,几十条视频数据的时候你用多条命令获取这些参数可能影响不大,因为数据量太小.但是实际问题你可能一次要处理上十万条数据,甚至上百万,上千万个数据时,那么精简的一条命令可以缩短脚本的响应时间,提高任务的执行速度,尽量减小了系统开销,这是在生产环境实际处理数据后的一点经验.]]></content>
      <categories>
        <category>server</category>
      </categories>
      <tags>
        <tag>mediainfo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php-MediaInfo获取媒体信息]]></title>
    <url>%2Fphp%2Fextension%2F77969671.html</url>
    <content type="text"><![CDATA[php获取视频时长?获取音轨信息?获取媒体文件的详细信息?php-mediainfo了解一下 准备工作 本机或者服务器必须有medainfolinux 1$ sudo apt-get install mediainfo mac 1$ brew install mediainfo 测试软件是否可用,可以在mplayer提供的各种媒体文件用来测试 1234567891011121314151617181920212223242526272829303132333435363738394041$ mediainfo 'http://samples.mplayerhq.hu/FLV/Enigma_Principles_of_Lust-part.flv'GeneralComplete name : http://samples.mplayerhq.hu/FLV/Enigma_Principles_of_Lust-part.flvFormat : Flash VideoFile size : 500 KiBDuration : 11 s 711 msOverall bit rate : 350 kb/sTagged date : UTC 2011-02-27 11:00:33Tagging application : inlet media FLVTool2 v1.0.6 - http://www.inlet-media.de/flvtool2VideoFormat : AVCFormat/Info : Advanced Video CodecFormat profile : Main@L2.1Format settings : CABAC / 3 Ref FramesFormat settings, CABAC : YesFormat settings, ReFrames : 3 framesCodec ID : 7Duration : 11 s 711 msWidth : 426 pixelsHeight : 240 pixelsDisplay aspect ratio : 16:9Frame rate mode : ConstantFrame rate : 30.000 FPSOriginal frame rate : 29.970 (29970/1000) FPSColor space : YUVChroma subsampling : 4:2:0Bit depth : 8 bitsScan type : ProgressiveAudioFormat : AACFormat/Info : Advanced Audio CodecFormat profile : LCCodec ID : 10-2Duration : 11 s 702 msChannel(s) : 2 channelsChannel positions : Front: L RSampling rate : 22.05 kHzFrame rate : 21.533 FPS (1024 SPF)Compression mode : Lossy 当你能看到上面显示的各种信息时说明你的环境已安装mediainfo 安装php-mediainfo github: php-mediainfo composer安装如下 1$ composer require mhor/php-mediainfo 实际使用过程 使用之前仔细看github中的readme中的Extra里面有这么一个提示:Support new mediainfo version (&gt;=17.10) 所以在初始化类的时候需如下: 123$mediaInfo = new MediaInfo();$mediaInfo-&gt;setConfig('use_oldxml_mediainfo_output_format', true);//这句必须加,因为目前的mediainfo版本早超过17.1,所以需要主动申明下config的格式$mediaInfoContainer = $mediaInfo-&gt;getInfo('music.mp3'); 现在百度和谷歌大部分的php-mediainfo资料都是16年左右的,当时mediainfo版本没有到17.1所以你如果按照他们的实际过程操作会提示错误,由于我在操作的时候根据错误提示修改了包的源码,虽然数据顺利取到了,但是宽高和duration数值都是个位数(仅发现的bug),我还纳闷这么成熟的包应该不会有这样的bug,最后仔细看了下readme文件,发现尾部这个提示后才觉得自作聪明要不得,这个坑因为自己瞎改源码耽误了小一个小时. 初始化类并处理返回值获得文件大小代码,$url是可以为远程文件或者本地文件 123456789$mediaInfo = new MediaInfo();$mediaInfo-&gt;setConfig('use_oldxml_mediainfo_output_format', true);$mediaInfoContainer = $mediaInfo-&gt;getInfo($url);//打印下 $mediaInfoContainer 变量,你就可以获取所有关于媒体信息的详细数据$jsonInfo = json_encode($mediaInfoContainer);$jsonInfo = json_decode($jsonInfo);$general = $jsonInfo-&gt;general;//获取文件的size大小 单位是 bit,general是基础信息$data['size'] = $general-&gt;file_size-&gt;bit; 获取文件format,可以用来逻辑判断 视频 还是 音频 还是 图片 来取对应信息,比如图片是没有duration字段的,视频和音频是包含音轨信息的等. 123456789101112131415161718$ext = $general-&gt;format-&gt;shortName;if ($ext == 'GIF' or $ext == 'JPEG' or $ext == 'PNG')&#123; //图片宽高 size $jsonInfo-&gt;images的结果是数组 $image_info = $jsonInfo-&gt;images[0]; $data['width'] = $image_info-&gt;width-&gt;absoluteValue ?: 0; $data['height'] = $image_info-&gt;height-&gt;absoluteValue ?: 0;&#125; elseif ($ext == 'MPEG-4') &#123; //mp4格式文件 先获取音轨数 $data['audio_count'] = $general-&gt;count_of_audio_streams ?: 0; //$jsonInfo-&gt;videos获得是视频信息的数组,因为视频文件里有可多包含多个视频轨道 $video_info = $jsonInfo-&gt;videos[0]; //获取第一个视频的时长 $data['duration'] = $video_info-&gt;duration-&gt;milliseconds ?: 0; //获取第一个视频的宽 $data['width'] = $video_info-&gt;width-&gt;absoluteValue ?: 0; //获取第一个视频的高 $data['height'] = $video_info-&gt;height-&gt;absoluteValue ?: 0;&#125; 最后 php-mediainfo是php处理媒体信息的一个扩展包,如果是日常处理媒体信息的脚本,我们可以直接调用mediainfo命令来获取各种想要的信息,详情可以看这篇博客Mediainfo命令实操记录]]></content>
      <categories>
        <category>php</category>
        <category>扩展</category>
      </categories>
      <tags>
        <tag>mediainfo</tag>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[30分钟快速搭建hexo3.7.0 + next主题6.4教程(持续更新最新版)]]></title>
    <url>%2Fhexo%2Fad0bedc4.html</url>
    <content type="text"><![CDATA[30分钟即可完成一个带评论、打赏、搜索、RSS、分类、标签等功能的博客高效的搭建让博主更加专注于内容的生产 准备工作 必须安装git和node,官网有各平台详细的安装过程 Node.js Git 准备一张头像和网站favicon 200*200方形或圆形头像 (用来显示作者头像) 32*32的favicon (浏览器打开网站标签的一个ico) hexo全局的图标配置信息均来自fontawesome 所有的配置项在修改的时候一定要记住 冒号 后是有一个空格的,不然保存后 在执行 hexo server 会失败 开始安装git和node安装完后进入到博客的文件夹内,执行下面代码(均在终端操作)123456$ npm install hexo-cli -g #全局安装hexo命令$ hexo init blog #在当前目录下,初始化hexo一个名为blog项目$ cd blog #进入该目录$ git clone https://github.com/theme-next/hexo-theme-next themes/next #安装next主题$ npm install #安装项目必备插件$ hexo server #本地启动项目 如果以上步骤均正确可以 点击即可看到博客首页 或 浏览器输入 localhost:4000 即可看到博客首页,如不能请检查之前的步骤是否正确,此时你已经完成了50%的工作 先找到 站点配置文件 blog/_config.yml重要提示:修改每一个配置的时候都可以刷新页面观看修改结果,如果不显示可以在终端的博客目录执行12$ hexo clean$ hexo server 站点配置 先设置hexo的next主题找到theme后修改为: 1theme: next #配置成刚下载的next主题 配置hexo网站相关信息找到site的设置 按下面备注修改相关信息 12345678# Sitetitle: 东行不西游 #网站标题subtitle: 风在前,无惧! #网站副标题description: 心猿不定，意马四驰 #描述,介绍网站的keywords: python,php,mysql,滑雪,摄影 #网站的关键字author: Bowen #博主姓名language: zh-CN #语言 zh-CN 是简体中文timezone: UTC #时区 设置hexo永久链接设置永久链接的目的是为了便于分享和seo优化.这样别人收藏地址后不会出现链接失效 12345# URLurl: https://dangbowen.com #网站的首页地址root: / #网站的根目录设置permalink: :year/:month/:day/:title.html # 这种 设置的url表现为2018/10/18/hello-world.html 样式 默认链接样式可修改为 (permalink配置只能有一种,关闭某种开头加 #) 1permalink: :category/:title.html #用分类和博客title当做url地址 设置hexo中的默认分类找到 Category &amp; Tag 12# Category &amp; Tagdefault_category: default #这里设置一个默认分类名称,如果第3条永久链接设置为 permalink: category/:title/ 那么没有分类的博客就会被放在default这个分类下进行归档 额外配置:hexo如何配置git信息(可跳过!后续新开一贴详细介绍)github和coding都提供page服务,这样我们就可以把博客静态资源发布到这2个仓库,然后用域名来访问博客,所有人都可以通过浏览器来观看你的博客.双仓库格式如下:_12345deploy: type: git repo: github: https://github.com/&#123;your_name&#125;/&#123;your_name&#125;.github.io,master #github 提供page的服务要求仓库名必须为 &#123;your_name&#125;.github.io 格式 比如你的github用户名为 abc 那么你必须建立一个 abc.github.io仓库 coding: https://git.coding.net/&#123;your_name&#125;/&#123;your_name&#125;.git,master #coding要求page服务的仓库名为 用户名 一样 .例如:用户名为abc 仓库名也必须为abc 先找到 主题配置文件 blog/themes/next/_config.yml ,修改配置的时候都可以刷新页面观看修改结果,如果不显示可以在终端的博客目录执行12$ hexo clean$ hexo server 主题配置 配置hexo网站的favicon把准备好的favicon放在 blog/themes/next/source/images/下 123favicon: small: /images/favicon-16x16-next.png #把favicon名修改成你自己的 medium: /images/favicon-32x32-next.png 配置hexo中的tag,categories菜单默认菜单只开启了首页和归档,hexo所有图标均来自fontawesome 1234567891011menu: #菜单设置为 菜单名: /菜单目录 || 菜单图标名字 home: / || home about: /about/ || user tags: /tags/ || tags categories: /categories/ || th archives: /archives/ || archive commonweal: /404/ || heartbeatmenu_settings: icons: true #显示图标 badges: true #显示统计信息 手动生成hexo菜单对应文件新菜单开启后是没有对应文件的,所以要手动生成about,tags,categories和404页面,这里我们将404替换成腾讯的公益页面新建about页面 12$ cd blog$ hexo new page about #about就是普通的布局一般用来介绍站点信息和博主信息等 新建一个tags页面 12$ cd blog$ hexo new page tags 找到tags文件 blog/source/tags/index.md 编辑它,在头部修改为 123456---title: All tagsdate: 2018-10-01 13:58:44 #时间随意type: "tags" #类型一定要为tagscomments: false #提示找个页面不需要评论,后续评论插件那里会详细介绍--- 新建一个categories页面 12$ cd blog$ hexo new page categories 找到categories文件 blog/source/categories/index.md 编辑它,在头部修改为 123456---title: 分类date: 2018-10-15 00:03:57type: "categories"comments: false--- 新建一个404页面 12$ cd blog$ hexo new page 404 找到404文件 blog/source/404/index.md 编辑它,内容全部替换成如下 123456789&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;&lt;meta charset="UTF-8"&gt;&lt;title&gt;404&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script type="text/javascript" src="//qzonestyle.gtimg.cn/qzone/hybrid/app/404/search_children.js" charset="utf-8" homePageUrl="/" homePageName="返回"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 配置hexo本地搜索安装插件,终端进入 cd blog 后执行: 1npm install hexo-generator-searchdb --save 主题配置文件如下: 12345local_search: enable: true trigger: auto top_n_per_article: 1 unescape: false 站点配置文件新添加如下代码: 12345search: path: search.xml field: post format: html limit: 100 设置hexo中的rss订阅rss需要安装一个插件,终端进入 cd blog 后执行: 1npm install hexo-generator-feed --save 刷新主页就可以看到rss 配置hexo站点的footer信息底部footer可以开关显示hexo版权,theme版权,还有建站时间等个性化配置 123456789101112footer: since: 2015 #建站开始时间 icon: name: user #设置 建站初始时间和至今时间中间的图标 默认是一个'小人像'更改user为heart可以变成一个'心' color: "#808080" #更改图标的颜色 红色为 '#ff0000' powered: enable: true #是否开启hexo驱动 version: true #是否开启hexo版本号 theme: enable: true #是否开启theme驱动 version: true #是否开启主题版本号 custom_text: Hosted by &lt;a target="_blank" rel="external nofollow" href="https://pages.coding.me"&gt;&lt;b&gt;Coding Pages&lt;/b&gt;&lt;/a&gt; #这里的底部标识是为了添加coding page服务时的版权声明 打开注释就可以看到底部有一个 hosted by coding pages 配置hexo中next主题样式选择next一共提供了4种首页样式,按照自己喜好选择一个,切记选择一个其他主题后其他的主题之前一定要加上# 12345# Schemesscheme: Muse#scheme: Mist#scheme: Pisces#scheme: Gemini hexo网站next主题侧边栏宽度,头像信息,头像设置圆形和头像旋转 12345678910111213sidebar: position: left #选择pisces 或者 gemini 主题是 可以 选择侧边栏 位置 调整左边或者右边 #position: right width: 300 # muse mist 主题 可以控制侧边栏的宽度 display: post #如果是muse mist 主题 可以选择 侧边栏弹出动作 post 是 只在内容页弹出 #display: always #全局弹出 #display: hide #全局隐藏侧边栏 右下角有角标唤出 #display: remove #移除侧边栏avatar: url: /images/avatar.gif #设置头像资源的位置 rounded: false #开启圆形头像 opacity: 1 #不透明的比例 0 就是完全透明 rotated: false #开启旋转 hexo中next主题的社交信息和友链配置 12345678910111213141516social: #和菜单设置格式一样 社交名字: 社交url || 社交图标 ,图标信息还是[fontawesome](https://fontawesome.com/v4.7.0/icons) GitHub: https://github.com/yourname || github E-Mail: mailto:yourname@gmail.com || envelope Google: https://plus.google.com/yourname || googlesocial_icons: enable: true #显示社交图标 icons_only: false #只显示图标的开关# Blog rollslinks_icon: link #友链的图标 参考上文links_title: Links #友链的title 比如你可以更改为 友情链接links_layout: block #友链摆放的样式,按块 一行一个#links_layout: inline #按线摆放,一行很多个 切记 同时只能一种样式links: Title: http://example.com/ #友链的地址 hexo中next主题首页文章不展示全文显示摘要,自动截取摘要和点击阅读全文跳转顶部 1234scroll_to_more: true #点击阅读全文后是否跳到&lt;!--more--&gt;标记处,设为false时点击阅读全文可以从头阅读auto_excerpt: #是否自动截取摘要 enable: false #设置为true则自动截取150字当做首页摘要 length: 150 #自动截取的字数 hexo中next主题首页文章属性显示创建时间,修改时间,分类 1234567post_meta: item_text: false # 设为true 可以一行显示 文章的所有属性 created_at: true #显示创建时间 updated_at: enabled: true #显示修改的时间 another_day: true #设true时 如果创建时间和修改时间一样则显示一个时间 categories: true #显示分类信息 hexo中的next增加页面阅读统计,字数统计,阅读时长新增busuanzi阅读统计 12345678busuanzi_count: enable: false #设true 开启 total_visitors: true #总阅读人数 uv数 total_visitors_icon: user #阅读总人数的图标 total_views: true #总阅读次数 pv数 total_views_icon: eye #阅读总次数的图标 post_views: true #开启内容阅读次数 post_views_icon: eye #内容页阅读数的图标 新增字数统计,阅读时长,先安装插件 1$ npm install hexo-symbols-count-time --save 主题配置信息如下: 123456symbols_count_time: separated_meta: true # false 会显示一行 item_text_post: true # 显示属性名称,设为false后只显示图标和统计数字,不显示属性的文字 item_text_total: true #底部footer是否显示字数统计属性文字 awl: 4 #计算字数的一个设置,没设置过 wpm: 275 #一分钟阅读的字数 站点配置新增如下: 1234567symbols_count_time: #文章内是否显示 symbols: true time: true # 网页底部是否显示 total_symbols: true total_time: true hexo中next主题给内容页里的代码块新增复制按钮 1234codeblock: copy_button: enable: false #增加复制按钮的开关 show_result: false #点击复制完后是否显示 复制成功 结果提示 hexo中next主题文章主页配置微信公众号 12345# Wechat Subscriberwechat_subscriber: enabled: true qcode: /images/wechat-qcode.jpg #微信公众号的二维码 description: 这是我的公众号 #公众号描述文字 hexo中next主题配置微信,支付宝打赏 12345# Rewardreward_comment: 一毛也是爱~ #打赏描述wechatpay: /images/wechat_pay.png #微信支付的二维码图片地址alipay: /images/ali_pay.png #支付宝的地址#bitcoin: /images/bitcoin.png #这个是设置比特币的... hexo中next主题新增 相关文章推荐安装推荐文章的插件 1$ npm install hexo-related-popular-posts --save 主题配置信息如下: 12345678910related_posts: enable: true title: 相关文章推荐 # 属性的命名 display_in_home: false #false代表首页不显示 params: maxCount: 5 #最多5条 #PPMixingRate: 0.0 #可以看github上 这个相关度介绍 #isDate: true #是否显示 日期 #isImage: false #是否显示配图 isExcerpt: false #是否显示摘要 hexo中next主题的文章原创申明给每一个原创文章开启版权保护 123post_copyright: enable: true #设置true就开启了 license: &lt;a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow" target="_blank"&gt;CC BY-NC-SA 4.0&lt;/a&gt; hexo中next主题更改code高亮样式 1highlight_theme: normal #可选值为 normal | night | night eighties | night blue | night bright 这几个挑一个喜欢的 hexo中next主题添加评论-Valine点击官网leancloud注册账号,获取自己的appid,appkey,再看valine官网设置下自己的leancloud 1234567891011valine: enable: true # 开启评论 appid: ~~~ # 刚申请 leancloud 的 appid appkey: ~~~ # 刚生情 leancloud 的 appkey notify: false # 是否邮件推送 详情看 https://github.com/xCss/Valine/wiki verify: false # placeholder: Just go go # 评论框里的placeholder信息 avatar: mm # gravatar style guest_info: nick,mail,link # custom comment header pageSize: 10 # 一页显示的评论条数 visitor: false # hexo中next主题配置网页body背景动态效果4个效果同时只能开启一个 1234canvas_nest: falsethree_waves: falsecanvas_lines: falsecanvas_sphere: false 常见问题 为什么hexo server报错?检查最近修改的配置文件中的各个配置项冒号后是否有空格,某些样式选择是否唯一 为什么menu设置完后,点击各个菜单无效,href=””现象?检查站点配置文件relative_link: false 如为true 改为 false即可 最后的最后由于6.4比5.x多了很多以前个性定制的配置,使得个性化的配置操作简单很多,不用修改样式和源码即可完成以前的定制效果,所以主题的更新还是要看个人的需求,如果功能够用的情况下还是保证创作博客为主,毕竟内容才是最能吸引读者的,共勉.]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World!]]></title>
    <url>%2Fdiary%2F1c291ca3.html</url>
    <content type="text"><![CDATA[写在开始编程前的一些话,也记录一些编程以外的事! 与君共勉! 写博客对我来说真的是一件很费劲巴拉的事.从14年开始到现在断断续续的搭建了4次,其实最后完整的站也就是WordPress,和现在这个,之前失败的经历无一不是把时间浪费在纠结细节而忽略最初的目的,既想要漂亮的后台编辑界面,还想要酷炫的前端,可惜我是一个后端开发,在选择前端组件上,轻微的强迫症让我吃尽苦头(改来改去,选来选去).甚至当年在看到阮一峰等人的博客时,心里想的更多的是这个博客居然这么简陋 所幸这几年想记录的、想分享的东西都存在书签和笔记里了,加上自己这几年的编程经历也有了一点点小小的积累,希望这些博客能够帮助到你! 放一张笔记截图]]></content>
      <categories>
        <category>diary</category>
      </categories>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
</search>
